
/// 1.简单使用Redux概念 
/// [Store]
///   [getState] page state tree 
///   [dispatch] 
///   [subscribe]
///   [Reducer]
/// [Effect]
/// [Reducer]
/// [Middleware]
/// 
/// [组件间的通讯]
///   1. 数据状态通信
///     同一个[Store]下的[组件]｜[组件组], 持有并订阅了同一个[Store], 使得数据流转变得非常天然.
///
///   2. 副作用通信
///     同一个[Store]下的[组件]｜[组件组]之间的存在[Effect]事件总线.
///
///   备注: 设计不具备跨[Store]之间[组件]的通信能力.
///}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// 组件层
/// [Page]: 基于Component封装的Page层，页面级别
/// 
/// [BasicComponent]: 组件单元模块，
///   [Dependencies]: 组件依赖部分
///   [Effect]: [副作用]部分
///   [Reducer]; [数据状态管理]部分
///   [View]: render 部分处理
/// 
/// [Component]: 单组件模式实现，单个RenderWidget绘制处理, [child]模式处理。
/// [Adapter]: 多组件模式实现，虚拟组组件，[chidlren]模式处理。
/// 
/// [Dependencies]
///   [Dependent]
///     [Connector] + [Component]
/// 三. [子组件]和[依赖]
///   [子组件] = [连接器] + [组件]
///   [子组件组] = [连接器] + [组件组]
///   [依赖] = [子组件表](插槽) + [子组件组]
///
///   1. 依赖的描述性和可编排性.
///   2. 依赖为[组件上下文]提供了,构建子[Widget]和[Widgets]的能力.
/// 
/// [ComponentWidget]
///   [Context]
///     0. [状态] 获取当前状态的能力
///     1. [UI]  构建Widget或Widgets的能力
///     2. [逻辑] 处理自身副作用[Effect]的能力, 及触发[Store]和广播到[EffectBus]的能力
///     3. [依赖] 通过声明的[依赖], 获得构建子[组件]或子[组件组]的能力
///     4. [子上下文] 任何的子[组件组]的上下文, 都附着于它的父组件组的上下文上.